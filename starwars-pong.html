<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Wars Pong</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #FFE81F;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .game-container {
            position: relative;
            width: 90vw;
            max-width: 1200px;
            height: 70vh;
            min-height: 500px;
            border: 3px solid #FFE81F;
            background: linear-gradient(45deg, #000428 0%, #004e92 100%);
            box-shadow: 0 0 50px #FFE81F;
            border-radius: 10px;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 50px;
            font-size: 2rem;
            font-weight: 700;
            text-shadow: 0 0 10px #FFE81F;
            z-index: 10;
        }
        
        .fps-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #FFE81F;
            padding: 12px 16px;
            border: 2px solid #FFE81F;
            border-radius: 8px;
            font-family: 'Orbitron', monospace;
            font-size: 1.1rem;
            font-weight: bold;
            text-shadow: 0 0 5px #FFE81F;
            z-index: 15;
            user-select: none;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 60px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
        }
        
        .fps-button:hover,
        .fps-button:active,
        .fps-button:focus {
            background: rgba(255, 232, 31, 0.2);
            box-shadow: 0 0 10px #FFE81F;
            transform: scale(1.05);
        }
        
        /* Mobile-specific improvements */
        @media (max-width: 768px) {
            .fps-button {
                top: 15px;
                right: 15px;
                padding: 15px 20px;
                font-size: 1.2rem;
                min-width: 70px;
                min-height: 50px;
                border-width: 3px;
            }
        }
        
        .fps-display {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            padding: 10px 15px;
            border: 2px solid #00ff00;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            font-weight: bold;
            text-shadow: 0 0 8px #00ff00;
            z-index: 14;
            user-select: none;
            transition: all 0.3s;
            opacity: 0;
            pointer-events: none;
            transform: translateY(-10px);
            touch-action: none;
        }
        
        /* Mobile FPS display adjustments */
        @media (max-width: 768px) {
            .fps-display {
                top: 75px;
                right: 15px;
                font-size: 0.9rem;
                padding: 12px 16px;
                min-width: 120px;
            }
        }
        
        .fps-display.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }
        
        .fps-display.good {
            color: #00ff00;
            border-color: #00ff00;
            text-shadow: 0 0 8px #00ff00;
        }
        
        .fps-display.warning {
            color: #ffff00;
            border-color: #ffff00;
            text-shadow: 0 0 8px #ffff00;
        }
        
        .fps-display.critical {
            color: #ff0000;
            border-color: #ff0000;
            text-shadow: 0 0 8px #ff0000;
        }
        
        .game-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 30;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 2px solid #FFE81F;
            border-radius: 10px;
            box-shadow: 0 0 30px #FFE81F;
            min-width: 300px;
            max-width: 90vw;
        }
        
        .game-menu h1 {
            font-size: 2.5rem;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #FFE81F;
            white-space: nowrap;
            overflow: hidden;
        }
        
        .game-menu button {
            background: transparent;
            color: #FFE81F;
            border: 2px solid #FFE81F;
            padding: 15px 30px;
            margin: 15px 5px;
            font-family: 'Orbitron', monospace;
            font-size: 1.1rem;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            display: block;
            width: 200px;
            margin-left: auto;
            margin-right: auto;
            position: relative;
            z-index: 31;
        }
        
        .game-menu button:hover {
            background: #FFE81F;
            color: #000;
            box-shadow: 0 0 20px #FFE81F;
        }
        
        .controls {
            margin-top: 30px;
            text-align: center;
            font-size: 0.8rem;
            opacity: 0.8;
            line-height: 1.4;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .ui-overlay {
                font-size: 1.2rem;
                gap: 20px;
                top: 10px;
            }
            
            .game-menu {
                padding: 25px 15px;
                min-width: 280px;
            }
            
            .game-menu h1 {
                font-size: 1.8rem;
                margin-bottom: 20px;
            }
            
            .game-menu button {
                font-size: 1rem;
                padding: 12px 20px;
                width: 180px;
                margin: 10px auto;
            }
            
            .controls {
                font-size: 0.7rem;
                margin-top: 20px;
            }
        }
        
        @media (max-width: 480px) {
            .game-container {
                width: 95vw;
                height: 60vh;
                min-height: 400px;
            }
            
            .ui-overlay {
                font-size: 1rem;
                gap: 15px;
                top: 5px;
            }
            
            .game-menu {
                padding: 20px 10px;
                min-width: 250px;
            }
            
            .game-menu h1 {
                font-size: 1.5rem;
                margin-bottom: 15px;
            }
            
            .game-menu button {
                font-size: 0.9rem;
                padding: 10px 15px;
                width: 160px;
                margin: 8px auto;
            }
            
            .controls {
                font-size: 0.6rem;
                margin-top: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div class="ui-overlay">
            <div><span id="player1Name">Player 1</span>: <span id="player1Score">0</span></div>
            <div><span id="player2Name">Player 2</span>: <span id="player2Score">0</span></div>
        </div>
        
        <div id="fpsButton" class="fps-button" onclick="toggleFpsDisplay()" ontouchstart="this.style.transform='scale(1.05)'" ontouchend="this.style.transform='scale(1)'">
            FPS
        </div>
        
        <div id="fpsDisplay" class="fps-display">
            <div>FPS: <span id="fpsValue">60</span></div>
            <div style="font-size: 0.7rem; margin-top: 4px; opacity: 0.8;">
                Mode: <span id="fpsMode">UNLIMITED</span><br>
                Press F to toggle • U for mode
            </div>
        </div>
        
        <div id="speechDebug" class="fps-display" style="top: 200px; background: rgba(139, 0, 0, 0.9); border-color: #ff6b6b; color: #ff6b6b; display: none;">
            <div>🎤 Speech: <span id="speechStatus">TESTING</span></div>
            <div style="font-size: 0.7rem; margin-top: 4px; opacity: 0.8;">
                Voices: <span id="voiceCount">0</span> | Attempts: <span id="speechAttemptCount">0</span><br>
                <span id="speechError">No errors</span>
            </div>
        </div>
        
        <button id="speechTestBtn" style="position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); background: #8B0000; color: #ff6b6b; border: 2px solid #ff6b6b; padding: 12px 20px; border-radius: 8px; font-family: 'Orbitron', monospace; font-weight: bold; cursor: pointer; z-index: 25; display: none; box-shadow: 0 0 15px rgba(255, 107, 107, 0.5); min-height: 44px; touch-action: manipulation;" onclick="manualSpeechTest()" ontouchstart="this.style.transform='translateX(-50%) scale(1.05)'" ontouchend="this.style.transform='translateX(-50%) scale(1)'">
            🎤 TEST VADER VOICE
        </button>
        
        <div id="gameMenu" class="game-menu">
            <h1>STAR WARS PONG</h1>
            <button onclick="showPlayerSetup('twoPlayer')">Two Player</button>
            <button onclick="showDifficultyMenu()">vs AI</button>
            <div class="controls">
                <p>Player 1: W/S keys or drag paddle | Player 2: Arrow Keys or drag paddle</p>
                <p>Press SPACE to pause | ESC to return to menu</p>
                <p style="font-size: 0.8rem; color: #888;">Press F for FPS monitor, U to cycle unlimited FPS modes</p>
            </div>
        </div>
        
        <div id="difficultyMenu" class="game-menu hidden">
            <h1>SELECT DIFFICULTY</h1>
            <button onclick="showPlayerSetup('ai', 'easy')">Easy AI</button>
            <button onclick="showPlayerSetup('ai', 'medium')">Medium AI</button>
            <button onclick="showPlayerSetup('ai', 'hard')">Hard AI</button>
            <button onclick="returnToMainMenu()">Back</button>
            <div class="controls">
                <p>Easy: Slower ball, inaccurate AI</p>
                <p>Medium: Normal speed, decent AI</p>
                <p>Hard: Fast ball, precise AI</p>
            </div>
        </div>
        
        <div id="playerSetup" class="game-menu hidden">
            <h1>PLAYER SETUP</h1>
            <div style="margin: 20px 0;">
                <label style="display: block; margin: 10px 0; font-size: 1rem;">Player 1 Name:</label>
                <input type="text" id="player1NameInput" maxlength="15" placeholder="Enter name" 
                       style="padding: 8px; font-family: Orbitron; background: #000; color: #FFE81F; 
                              border: 2px solid #FFE81F; border-radius: 5px; text-align: center;">
            </div>
            <div id="player2Setup" style="margin: 20px 0;">
                <label style="display: block; margin: 10px 0; font-size: 1rem;">Player 2 Name:</label>
                <input type="text" id="player2NameInput" maxlength="15" placeholder="Enter name"
                       style="padding: 8px; font-family: Orbitron; background: #000; color: #FFE81F; 
                              border: 2px solid #FFE81F; border-radius: 5px; text-align: center;">
            </div>
            <button onclick="confirmPlayerSetup()">Start Game</button>
            <button onclick="backFromPlayerSetup()">Back</button>
        </div>
        
        <div id="roundEndMenu" class="game-menu hidden">
            <h1>ROUND COMPLETE</h1>
            <div id="roundScore" style="margin: 20px 0; font-size: 1.5rem;"></div>
            <button onclick="continueGame()">Continue Playing</button>
            <button onclick="showNameChange()">Change Names</button>
            <button onclick="returnToMenu()">Main Menu</button>
        </div>
        
        <div id="nameChangeMenu" class="game-menu hidden">
            <h1>CHANGE NAMES</h1>
            <div style="margin: 20px 0;">
                <label style="display: block; margin: 10px 0; font-size: 1rem;">Player 1 Name:</label>
                <input type="text" id="newPlayer1Name" maxlength="15" 
                       style="padding: 8px; font-family: Orbitron; background: #000; color: #FFE81F; 
                              border: 2px solid #FFE81F; border-radius: 5px; text-align: center;">
            </div>
            <div id="nameChangePlayer2" style="margin: 20px 0;">
                <label style="display: block; margin: 10px 0; font-size: 1rem;">Player 2 Name:</label>
                <input type="text" id="newPlayer2Name" maxlength="15" 
                       style="padding: 8px; font-family: Orbitron; background: #000; color: #FFE81F; 
                              border: 2px solid #FFE81F; border-radius: 5px; text-align: center;">
            </div>
            <button onclick="applyNameChanges()">Apply Changes</button>
            <button onclick="backToRoundEnd()">Back</button>
        </div>
    </div>
    
    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameMenu = document.getElementById('gameMenu');
        const player1ScoreEl = document.getElementById('player1Score');
        const player2ScoreEl = document.getElementById('player2Score');
        
        // Interval cleanup tracking
        const activeIntervals = new Set();
        
        // Safe interval management
        function createManagedInterval(callback, delay) {
            const intervalId = setInterval(callback, delay);
            activeIntervals.add(intervalId);
            return intervalId;
        }
        
        function clearManagedInterval(intervalId) {
            clearInterval(intervalId);
            activeIntervals.delete(intervalId);
        }
        
        function clearAllIntervals() {
            activeIntervals.forEach(id => clearInterval(id));
            activeIntervals.clear();
        }
        
        // Game state
        let gameMode = null;
        let gameDifficulty = 'medium'; // easy, medium, hard
        let gameRunning = false;
        let gamePaused = false;
        
        // Game configuration constants
        const GAME_CONFIG = {
            WINNING_SCORE: 11,
            PADDLE_SPEED: 3.5,
            BALL_BASE_SPEED: 2.5,
            BALL_SPEED_INCREASE: 0.05,
            PADDLE_WIDTH: 15,
            PADDLE_HEIGHT: 80,
            BALL_SIZE: 12,
            TOUCH_PADDING: 20,
            MAX_PLAYER_NAME_LENGTH: 15,
            FPS_COUNTER_UPDATE_INTERVAL: 1000,
            COUNTDOWN_DURATION: 3,
            MAX_BALL_RESET_RETRIES: 50,
            MAX_SPEECH_RETRY_ATTEMPTS: 20,
            LOCALSTORAGE_SIZE_LIMIT: 1000000
        };
        
        // Player names
        let player1Name = 'Player 1';
        let player2Name = 'Player 2';
        
        // Game objects
        let paddle1, paddle2, ball;
        let keys = {};
        
        // Touch controls
        let touchControls = {
            active: false,
            startY: 0,
            paddle1Touch: null,
            paddle2Touch: null,
            dragThreshold: 10
        };
        
        // Audio context for sound effects
        let audioContext;
        let speechSynthesis = window.speechSynthesis;
        let audioInitialized = false;
        let speechInitialized = false;
        let availableVoices = [];
        let speechDebugMode = true;
        let speechAttempts = 0;
        let lastSpeechError = null;
        
        // FPS counter variables
        let fpsCounter = {
            displayEnabled: false,
            frameCount: 0,
            lastTime: performance.now(),
            fps: 60
        };
        
        // Unlimited FPS settings
        let unlimitedFPS = {
            enabled: true, // Enable unlimited FPS by default
            method: 'hybrid' // 'raf', 'timeout', 'hybrid', 'immediate'
        };
        
        // High performance frame scheduler
        function scheduleNextFrame(callback) {
            if (!unlimitedFPS.enabled) {
                requestAnimationFrame(callback);
                return;
            }
            
            switch (unlimitedFPS.method) {
                case 'timeout':
                    setTimeout(callback, 0);
                    break;
                case 'immediate':
                    if (typeof setImmediate !== 'undefined') {
                        setImmediate(callback);
                    } else {
                        setTimeout(callback, 0);
                    }
                    break;
                case 'hybrid':
                    // Use both for maximum performance
                    setTimeout(() => {
                        requestAnimationFrame(callback);
                    }, 0);
                    break;
                default:
                    requestAnimationFrame(callback);
            }
        }
        
        // Darth Vader style insults
        const vaderInsults = [
            "Your lack of skill disturbs me.",
            "The Force is weak with this one.",
            "You have failed me for the last time.",
            "Your deflection skills are as clumsy as they are stupid.",
            "I find your lack of pong faith disturbing.",
            "You are beaten. It is useless to resist.",
            "The circle is now complete. You are the learner.",
            "You underestimate the power of the AI side.",
            "Your paddle work needs improvement, young padawan.",
            "Don't be too proud of this technological terror you call skill.",
            "The ability to hit a ball does not make you intelligent.",
            "You may fire when ready... but you'll still miss.",
            "I sense great fear in you. Fear leads to losing.",
            "Your overconfidence is your weakness, human.",
            "Perhaps you thought you were being treated unfairly? Good!"
        ];
        
        // Insult tracking to prevent repeats
        let usedInsults = [];
        let currentInsultIndex = 0;
        
        // Initialize audio with mobile compatibility
        function initAudio() {
            if (!audioContext) {
                try {
                    // Check if AudioContext is supported
                    const AudioContextConstructor = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContextConstructor) {
                        console.warn('AudioContext not supported in this browser');
                        return Promise.resolve();
                    }
                    
                    audioContext = new AudioContextConstructor();
                    
                    // Handle suspended context (mobile requirement)
                    if (audioContext.state === 'suspended') {
                        return audioContext.resume().then(() => {
                            audioInitialized = true;
                            console.log('Audio context resumed successfully');
                        }).catch(err => {
                            console.warn('Could not resume audio context:', err);
                            // Continue without audio instead of failing
                            audioInitialized = false;
                        });
                    } else {
                        audioInitialized = true;
                    }
                } catch (err) {
                    console.warn('Could not create audio context:', err);
                    audioContext = null;
                    audioInitialized = false;
                    // Continue gracefully without audio
                }
            }
            return Promise.resolve();
        }
        
        // Enhanced audio context management with speech integration
        function ensureAudioContext() {
            console.log('🔊 ensureAudioContext called');
            
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    audioInitialized = true;
                    console.log('✅ Audio context resumed');
                    
                    // Force speech synthesis initialization
                    if (!speechInitialized) {
                        console.log('🎤 Initializing speech after audio context resume');
                        initSpeechSynthesis();
                    }
                    
                    // Show debug info
                    showSpeechDebug();
                    
                }).catch(err => {
                    console.warn('❌ Could not resume audio context:', err);
                });
            } else {
                // Mark as initialized and force speech init
                audioInitialized = true;
                console.log('✅ Audio context ready');
                
                if (!speechInitialized) {
                    console.log('🎤 Initializing speech synthesis');
                    initSpeechSynthesis();
                }
                
                showSpeechDebug();
            }
        }
        
        // FPS counter functions
        function toggleFpsDisplay() {
            fpsCounter.displayEnabled = !fpsCounter.displayEnabled;
            const fpsDisplay = document.getElementById('fpsDisplay');
            if (fpsCounter.displayEnabled) {
                fpsDisplay.classList.add('visible');
                updateFpsMode();
            } else {
                fpsDisplay.classList.remove('visible');
            }
        }
        
        function cycleFpsMode() {
            const modes = ['hybrid', 'timeout', 'immediate', 'raf'];
            const currentIndex = modes.indexOf(unlimitedFPS.method);
            const nextIndex = (currentIndex + 1) % modes.length;
            unlimitedFPS.method = modes[nextIndex];
            unlimitedFPS.enabled = (unlimitedFPS.method !== 'raf');
            updateFpsMode();
        }
        
        function updateFpsMode() {
            const modeElement = document.getElementById('fpsMode');
            if (modeElement) {
                let modeText = unlimitedFPS.enabled ? 'UNLIMITED' : 'V-SYNC';
                if (unlimitedFPS.enabled) {
                    modeText += ` (${unlimitedFPS.method.toUpperCase()})`;
                }
                modeElement.textContent = modeText;
            }
        }
        
        function updateFpsCounter() {
            // Always calculate FPS for accuracy
            fpsCounter.frameCount++;
            const currentTime = performance.now();
            
            if (currentTime - fpsCounter.lastTime >= 1000) {
                fpsCounter.fps = Math.round((fpsCounter.frameCount * 1000) / (currentTime - fpsCounter.lastTime));
                
                // Only update display if visible and elements exist
                if (fpsCounter.displayEnabled) {
                    const fpsValueElement = document.getElementById('fpsValue');
                    const fpsDisplayElement = document.getElementById('fpsDisplay');
                    
                    if (fpsValueElement) {
                        fpsValueElement.textContent = fpsCounter.fps;
                    }
                    
                    // Color code the FPS display if element exists
                    if (fpsDisplayElement) {
                        fpsDisplayElement.classList.remove('good', 'warning', 'critical');
                        
                        if (fpsCounter.fps >= 55) {
                            fpsDisplayElement.classList.add('good');
                        } else if (fpsCounter.fps >= 30) {
                            fpsDisplayElement.classList.add('warning');
                        } else {
                            fpsDisplayElement.classList.add('critical');
                        }
                    }
                }
                
                fpsCounter.frameCount = 0;
                fpsCounter.lastTime = currentTime;
            }
        }
        
        // Show speech debug info on mobile
        function showSpeechDebug() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile || speechDebugMode) {
                const speechDebugElement = document.getElementById('speechDebug');
                const speechTestBtnElement = document.getElementById('speechTestBtn');
                
                if (speechDebugElement) {
                    speechDebugElement.style.display = 'block';
                }
                if (speechTestBtnElement) {
                    speechTestBtnElement.style.display = 'block';
                }
                updateSpeechDebug();
            }
        }
        
        function updateSpeechDebug() {
            const speechStatusElement = document.getElementById('speechStatus');
            const voiceCountElement = document.getElementById('voiceCount');
            const speechAttemptCountElement = document.getElementById('speechAttemptCount');
            const speechErrorElement = document.getElementById('speechError');
            
            if (speechStatusElement) {
                speechStatusElement.textContent = speechInitialized ? 'READY' : 'INIT';
            }
            if (voiceCountElement) {
                voiceCountElement.textContent = availableVoices.length;
            }
            if (speechAttemptCountElement) {
                speechAttemptCountElement.textContent = speechAttempts;
            }
            if (speechErrorElement) {
                speechErrorElement.textContent = lastSpeechError || 'No errors';
            }
        }
        
        // Manual speech test function for mobile debugging
        function manualSpeechTest() {
            console.log('🎯 Manual speech test triggered');
            audioInitialized = true; // Force enable
            speakAsVader('Your lack of skill disturbs me', false);
        }
        
        // Multiple speech synthesis initialization methods
        function initSpeechSynthesis() {
            if (!speechSynthesis) {
                lastSpeechError = 'Speech synthesis not available';
                console.warn(lastSpeechError);
                updateSpeechDebug();
                return false;
            }
            
            speechAttempts++;
            console.log('Speech init attempt #', speechAttempts);
            
            // Load voices and mark as initialized
            function loadVoices() {
                availableVoices = speechSynthesis.getVoices();
                speechInitialized = availableVoices.length > 0;
                
                if (speechInitialized) {
                    console.log('✅ Speech synthesis initialized with', availableVoices.length, 'voices');
                    availableVoices.forEach((voice, i) => {
                        console.log(`Voice ${i}: ${voice.name} (${voice.lang}) - ${voice.gender || 'unknown gender'}`);
                    });
                    lastSpeechError = null;
                } else {
                    lastSpeechError = 'No voices loaded';
                    console.warn('❌ No voices available');
                }
                updateSpeechDebug();
            }
            
            // Multiple methods to load voices
            loadVoices(); // Try immediately
            
            // Method 1: voiceschanged event
            speechSynthesis.addEventListener('voiceschanged', loadVoices);
            
            // Method 2: Force voice loading with timeout
            setTimeout(() => {
                speechSynthesis.getVoices();
                loadVoices();
            }, 100);
            
            // Method 3: Repeated attempts for stubborn mobile browsers
            let attempts = 0;
            const voiceLoader = createManagedInterval(() => {
                attempts++;
                const voices = speechSynthesis.getVoices();
                if (voices.length > 0 || attempts > 10) {
                    clearManagedInterval(voiceLoader);
                    if (voices.length > 0) {
                        availableVoices = voices;
                        speechInitialized = true;
                        console.log('✅ Voices loaded after', attempts, 'attempts');
                        updateSpeechDebug();
                    }
                }
            }, 200);
            
            return true;
        }
        
        // Ultra-aggressive mobile speech function with multiple fallbacks
        function speakAsVader(text, isScream = false) {
            console.log('🎤 speakAsVader called:', text);
            
            // Show visual indicator that speech was attempted
            showSpeechAttempt(text);
            
            if (!speechSynthesis) {
                lastSpeechError = 'speechSynthesis not available';
                console.error('❌', lastSpeechError);
                updateSpeechDebug();
                return;
            }
            
            // Try to initialize if not ready
            if (!speechInitialized) {
                console.log('🔄 Re-initializing speech synthesis...');
                initSpeechSynthesis();
                
                // Try again after a delay
                setTimeout(() => speakAsVader(text, isScream), 500);
                return;
            }
            
            // Force user interaction check
            if (!audioInitialized && !checkUserInteraction()) {
                lastSpeechError = 'User interaction required';
                console.warn('⚠️', lastSpeechError);
                updateSpeechDebug();
                return;
            }
            
            try {
                // Multiple speech attempts with different methods
                attemptSpeech(text, isScream, 0);
                
            } catch (error) {
                lastSpeechError = error.message;
                console.error('❌ Speech error:', error);
                updateSpeechDebug();
            }
        }
        
        // Check and force user interaction
        function checkUserInteraction() {
            if (!audioInitialized) {
                // Try to create a dummy audio context to test user interaction
                try {
                    // Check if AudioContext constructor is available
                    const AudioContextConstructor = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContextConstructor) {
                        console.warn('AudioContext not supported in this browser');
                        return false;
                    }
                    
                    const testContext = new AudioContextConstructor();
                    if (testContext.state !== 'suspended') {
                        audioInitialized = true;
                    }
                    
                    // Ensure context is properly closed
                    if (testContext.close) {
                        testContext.close().catch(err => {
                            console.warn('Error closing test audio context:', err);
                        });
                    }
                } catch (e) {
                    console.warn('Audio context test failed:', e);
                    // Don't throw error, just log and continue without audio
                    return false;
                }
            }
            return audioInitialized;
        }
        
        // Show visual speech attempt indicator
        function showSpeechAttempt(text) {
            const indicator = document.createElement('div');
            indicator.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(139, 0, 0, 0.95);
                color: #ff6b6b;
                padding: 20px;
                border: 2px solid #ff6b6b;
                border-radius: 10px;
                font-family: 'Orbitron', monospace;
                font-weight: bold;
                z-index: 9999;
                text-align: center;
                box-shadow: 0 0 20px #ff6b6b;
            `;
            indicator.innerHTML = `🎤 VADER SPEAKS:<br>"${text}"`;
            document.body.appendChild(indicator);
            
            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            }, 3000);
        }
        
        // Multiple speech attempt methods
        function attemptSpeech(text, isScream = false, attemptNumber = 0) {
            if (attemptNumber > 3) {
                lastSpeechError = 'Max speech attempts reached';
                console.error('❌ Giving up after', attemptNumber, 'attempts');
                updateSpeechDebug();
                return;
            }
            
            console.log(`🎤 Speech attempt #${attemptNumber + 1}`);
            
            // Cancel any ongoing speech
            try {
                speechSynthesis.cancel();
            } catch (e) {
                console.warn('Cancel failed:', e);
            }
            
            // Wait for cancel to complete
            const delay = attemptNumber * 200 + 100;
            setTimeout(() => {
                try {
                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    // Aggressive settings for mobile
                    if (isScream) {
                        utterance.rate = 0.3;
                        utterance.pitch = 0.1;
                        utterance.volume = 1.0;
                    } else {
                        utterance.rate = 0.6;
                        utterance.pitch = 0.2;
                        utterance.volume = 1.0; // Max volume for mobile
                    }
                    
                    // Better voice selection for mobile
                    const vaderVoice = findBestVaderVoice();
                    if (vaderVoice) {
                        utterance.voice = vaderVoice;
                        console.log('✅ Using voice:', vaderVoice.name);
                    } else {
                        console.warn('⚠️ No suitable voice found');
                    }
                    
                    // Enhanced error handling
                    utterance.onerror = function(event) {
                        lastSpeechError = `Speech error: ${event.error}`;
                        console.error('❌ Speech error:', event.error);
                        updateSpeechDebug();
                        
                        // Try again with different settings
                        if (attemptNumber < 3) {
                            setTimeout(() => attemptSpeech(text, isScream, attemptNumber + 1), 1000);
                        }
                    };
                    
                    utterance.onstart = function() {
                        console.log('✅ Speech started successfully:', text);
                        lastSpeechError = null;
                        updateSpeechDebug();
                    };
                    
                    utterance.onend = function() {
                        console.log('✅ Speech completed');
                    };
                    
                    utterance.onpause = function() {
                        console.log('⏸️ Speech paused');
                    };
                    
                    utterance.onresume = function() {
                        console.log('▶️ Speech resumed');
                    };
                    
                    // Force speech synthesis
                    console.log('🗣️ Speaking:', text);
                    speechSynthesis.speak(utterance);
                    
                    // Fallback: if speech doesn't start within 2 seconds, try again
                    setTimeout(() => {
                        if (speechSynthesis.speaking === false && speechSynthesis.pending === false) {
                            console.warn('⚠️ Speech did not start, retrying...');
                            if (attemptNumber < 3) {
                                attemptSpeech(text, isScream, attemptNumber + 1);
                            }
                        }
                    }, 2000);
                    
                } catch (error) {
                    lastSpeechError = error.message;
                    console.error('❌ Speech creation error:', error);
                    updateSpeechDebug();
                    
                    // Try again
                    if (attemptNumber < 3) {
                        setTimeout(() => attemptSpeech(text, isScream, attemptNumber + 1), 1000);
                    }
                }
            }, delay);
        }
        
        // Find the best voice for Vader
        function findBestVaderVoice() {
            if (availableVoices.length === 0) return null;
            
            // Priority order for voice selection
            const voicePreferences = [
                v => v.name.toLowerCase().includes('male'),
                v => v.name.toLowerCase().includes('daniel'),
                v => v.name.toLowerCase().includes('alex'),
                v => v.name.toLowerCase().includes('bass'),
                v => v.name.toLowerCase().includes('deep'),
                v => v.name.toLowerCase().includes('low'),
                v => v.gender && v.gender.toLowerCase() === 'male',
                v => v.lang.startsWith('en') && !v.name.toLowerCase().includes('female'),
                v => !v.name.toLowerCase().includes('female'),
                v => true // Any voice as last resort
            ];
            
            for (const preference of voicePreferences) {
                const voice = availableVoices.find(preference);
                if (voice) {
                    console.log('🎯 Selected voice:', voice.name, voice.lang);
                    return voice;
                }
            }
            
            return availableVoices[0];
        }
        
        // Vader evil laugh function
        function vaderLaugh() {
            if (!audioContext || !audioInitialized) {
                ensureAudioContext();
                return;
            }
            
            // Generate clearer, louder evil laugh sound effect
            const laughSegments = [
                {freq: 120, start: 0, duration: 0.15},     // "Mwa"
                {freq: 140, start: 0.15, duration: 0.12},  // "ha"
                {freq: 130, start: 0.27, duration: 0.12},  // "ha"
                {freq: 150, start: 0.39, duration: 0.12},  // "ha"
                {freq: 135, start: 0.51, duration: 0.15},  // "ha"
                {freq: 160, start: 0.66, duration: 0.18},  // "haa"
                {freq: 125, start: 0.84, duration: 0.2}    // "aaa"
            ];
            
            laughSegments.forEach(segment => {
                // Main laugh oscillator
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const startTime = audioContext.currentTime + segment.start;
                const endTime = startTime + segment.duration;
                
                oscillator.frequency.setValueAtTime(segment.freq, startTime);
                oscillator.type = 'sawtooth';
                
                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(0.25, startTime + 0.02); // Much louder
                gainNode.gain.exponentialRampToValueAtTime(0.001, endTime);
                
                oscillator.start(startTime);
                oscillator.stop(endTime);
                
                // Add harmonic for richer sound
                const harmonic = audioContext.createOscillator();
                const harmonicGain = audioContext.createGain();
                
                harmonic.connect(harmonicGain);
                harmonicGain.connect(audioContext.destination);
                
                harmonic.frequency.setValueAtTime(segment.freq * 2, startTime); // Octave higher
                harmonic.type = 'triangle';
                
                harmonicGain.gain.setValueAtTime(0, startTime);
                harmonicGain.gain.linearRampToValueAtTime(0.12, startTime + 0.02); // Half volume of main
                harmonicGain.gain.exponentialRampToValueAtTime(0.001, endTime);
                
                harmonic.start(startTime);
                harmonic.stop(endTime);
            });
        }
        
        // AI heckling function with no repeats
        function aiHeckle() {
            if (gameMode === 'ai' && Math.random() < 0.8) { // 80% chance to heckle
                // Get next insult in sequence without repeating
                const insult = getNextInsult();
                
                // Delay the insult slightly for dramatic effect
                setTimeout(() => {
                    speakAsVader(insult);
                    
                    // Show the insult text on screen briefly
                    showHeckleText(insult);
                    
                    // 80% chance to laugh after heckling
                    if (Math.random() < 0.8) {
                        setTimeout(() => {
                            vaderLaugh();
                        }, 2500); // Laugh after the insult finishes
                    }
                }, 800);
            }
        }
        
        // Get next insult without repeating until all are used
        function getNextInsult() {
            // If we've used all insults, reset the list
            if (usedInsults.length >= vaderInsults.length) {
                usedInsults = [];
                currentInsultIndex = 0;
            }
            
            // Find next unused insult
            let insult;
            do {
                insult = vaderInsults[currentInsultIndex];
                currentInsultIndex = (currentInsultIndex + 1) % vaderInsults.length;
            } while (usedInsults.includes(insult) && usedInsults.length < vaderInsults.length);
            
            // Mark this insult as used
            usedInsults.push(insult);
            
            return insult;
        }
        
        // Show heckling text on screen
        let heckleText = {
            active: false,
            message: '',
            startTime: 0,
            duration: 3000 // 3 seconds
        };
        
        function showHeckleText(message) {
            heckleText.active = true;
            heckleText.message = message;
            heckleText.startTime = Date.now();
        }
        
        function drawHeckleText() {
            if (!heckleText.active) return;
            
            const elapsed = Date.now() - heckleText.startTime;
            if (elapsed > heckleText.duration) {
                heckleText.active = false;
                return;
            }
            
            // Calculate opacity for fade in/out effect
            let opacity = 1;
            if (elapsed < 500) {
                opacity = elapsed / 500; // Fade in
            } else if (elapsed > heckleText.duration - 500) {
                opacity = (heckleText.duration - elapsed) / 500; // Fade out
            }
            
            // Draw dark background for text
            ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.7})`;
            ctx.fillRect(0, canvas.height - 120, canvas.width, 80);
            
            // Draw the insult text
            ctx.fillStyle = `rgba(255, 232, 31, ${opacity})`; // Star Wars yellow
            ctx.font = 'bold 18px Orbitron';
            ctx.textAlign = 'center';
            ctx.shadowColor = `rgba(255, 232, 31, ${opacity})`;
            ctx.shadowBlur = 10;
            
            // Word wrap for long messages
            const words = heckleText.message.split(' ');
            const maxWidth = canvas.width - 40;
            let line = '';
            let y = canvas.height - 80;
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i] + ' ';
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && line !== '') {
                    ctx.fillText(line.trim(), canvas.width / 2, y);
                    line = words[i] + ' ';
                    y += 25;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line.trim(), canvas.width / 2, y);
            
            ctx.shadowBlur = 0;
        }
        
        // Sound generation functions
        function playBeep(frequency = 440, duration = 0.1, volume = 0.1) {
            if (!audioContext || !audioInitialized) {
                ensureAudioContext();
                return;
            }
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        // Victory music generation - Original epic space adventure theme
        function playVictoryMusic() {
            if (!audioContext || !audioInitialized) {
                ensureAudioContext();
                return;
            }
            
            // Original heroic fanfare inspired by classic space opera themes
            const notes = [
                // Opening fanfare - rising triumphant phrase
                {freq: 523, start: 0, duration: 1.0},     // C (strong opening)
                {freq: 784, start: 1.0, duration: 1.0},   // G (perfect fifth up)
                {freq: 1047, start: 2.0, duration: 0.8},  // C (octave higher)
                {freq: 932, start: 2.8, duration: 0.4},   // Bb
                {freq: 880, start: 3.2, duration: 0.8},   // A
                
                // Heroic descent and rise
                {freq: 784, start: 4.0, duration: 0.6},   // G
                {freq: 698, start: 4.6, duration: 0.4},   // F
                {freq: 784, start: 5.0, duration: 0.8},   // G
                {freq: 1047, start: 5.8, duration: 1.2},  // C (triumphant return)
                
                // Grand finale
                {freq: 1175, start: 7.0, duration: 0.5},  // D
                {freq: 1047, start: 7.5, duration: 0.5},  // C
                {freq: 932, start: 8.0, duration: 0.5},   // Bb
                {freq: 1047, start: 8.5, duration: 1.5}   // C (final victory note)
            ];
            
            notes.forEach(note => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(note.freq, audioContext.currentTime + note.start);
                oscillator.type = 'sawtooth';
                
                const startTime = audioContext.currentTime + note.start;
                const endTime = startTime + note.duration;
                
                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(0.15, startTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, endTime);
                
                oscillator.start(startTime);
                oscillator.stop(endTime);
            });
        }
        
        // Defeat music generation - Darker version of victory theme
        function playDefeatMusic() {
            if (!audioContext || !audioInitialized) {
                ensureAudioContext();
                return;
            }
            
            // Same melody as victory but in minor key and lower octave
            const notes = [
                {freq: 220, start: 0, duration: 0.6},     // A (lower octave)
                {freq: 220, start: 0.6, duration: 0.6},   // A
                {freq: 220, start: 1.2, duration: 0.6},   // A
                {freq: 174, start: 1.8, duration: 0.45},  // F (minor)
                {freq: 261, start: 2.25, duration: 0.15}, // C
                {freq: 220, start: 2.4, duration: 0.6},   // A
                {freq: 174, start: 3.0, duration: 0.45},  // F
                {freq: 261, start: 3.45, duration: 0.15}, // C
                {freq: 220, start: 3.6, duration: 1.2},   // A
                
                {freq: 311, start: 4.8, duration: 0.6},   // Eb (minor equivalent)
                {freq: 311, start: 5.4, duration: 0.6},   // Eb
                {freq: 311, start: 6.0, duration: 0.6},   // Eb
                {freq: 329, start: 6.6, duration: 0.45},  // E
                {freq: 261, start: 7.05, duration: 0.15}, // C
                {freq: 207, start: 7.2, duration: 0.6},   // G# (minor)
                {freq: 174, start: 7.8, duration: 0.45},  // F
                {freq: 261, start: 8.25, duration: 0.15}, // C
                {freq: 220, start: 8.4, duration: 1.2}    // A
            ];
            
            notes.forEach(note => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(note.freq, audioContext.currentTime + note.start);
                oscillator.type = 'square'; // Harsher sound for defeat
                
                const startTime = audioContext.currentTime + note.start;
                const endTime = startTime + note.duration;
                
                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(0.12, startTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, endTime);
                
                oscillator.start(startTime);
                oscillator.stop(endTime);
            });
        }
        
        // Resize canvas
        function resizeCanvas() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // Reposition paddles if game is running
            if (gameRunning && paddle2) {
                paddle2.x = canvas.width - 45;
            }
        }
        
        // Game objects
        class Paddle {
            constructor(x, y, isPlayer1 = true) {
                this.x = x;
                this.y = y;
                this.width = GAME_CONFIG.PADDLE_WIDTH;
                this.height = GAME_CONFIG.PADDLE_HEIGHT;
                this.speed = GAME_CONFIG.PADDLE_SPEED; // Reduced from 5 to 3.5 for smoother movement
                this.velocity = 0; // For smooth acceleration/deceleration
                this.acceleration = 0.8;
                this.friction = 0.85;
                this.isPlayer1 = isPlayer1;
                this.score = 0;
            }
            
            update() {
                if (this.isPlayer1) {
                    // Handle touch input for player 1
                    if (touchControls.paddle1Touch) {
                        // Touch control is active, ignore keyboard
                        this.velocity = 0;
                    } else {
                        // Smooth player movement with acceleration
                        let targetVelocity = 0;
                        if (keys['w'] || keys['W']) targetVelocity = -this.speed;
                        if (keys['s'] || keys['S']) targetVelocity = this.speed;
                        
                        // Smooth acceleration towards target velocity
                        if (targetVelocity !== 0) {
                            this.velocity += (targetVelocity - this.velocity) * this.acceleration;
                        } else {
                            this.velocity *= this.friction; // Apply friction when no input
                        }
                        
                        // Stop very small movements to prevent jitter
                        if (Math.abs(this.velocity) < 0.1) this.velocity = 0;
                        
                        this.y += this.velocity;
                    }
                    
                } else if (gameMode === 'twoPlayer') {
                    // Handle touch input for player 2
                    if (touchControls.paddle2Touch) {
                        // Touch control is active, ignore keyboard
                        this.velocity = 0;
                    } else {
                        // Smooth player 2 movement
                        let targetVelocity = 0;
                        if (keys['ArrowUp']) targetVelocity = -this.speed;
                        if (keys['ArrowDown']) targetVelocity = this.speed;
                        
                        if (targetVelocity !== 0) {
                            this.velocity += (targetVelocity - this.velocity) * this.acceleration;
                        } else {
                            this.velocity *= this.friction;
                        }
                        
                        if (Math.abs(this.velocity) < 0.1) this.velocity = 0;
                        
                        this.y += this.velocity;
                    }
                    
                } else if (gameMode === 'ai') {
                    // AI with difficulty-based behavior
                    if (ball && ball.x !== undefined) {
                        this.updateAIByDifficulty();
                    }
                }
                
                // Keep paddle in bounds
                if (this.y < 0) {
                    this.y = 0;
                    this.velocity = 0; // Stop velocity when hitting boundary
                }
                if (this.y + this.height > canvas.height) {
                    this.y = canvas.height - this.height;
                    this.velocity = 0; // Stop velocity when hitting boundary
                }
            }
            
            updateAIByDifficulty() {
                const ballCenter = ball.y + ball.size / 2;
                const paddleCenter = this.y + this.height / 2;
                
                let targetY = ballCenter;
                let aiSpeed, reactionDelay, accuracy;
                
                // Set AI parameters based on difficulty
                switch(gameDifficulty) {
                    case 'easy':
                        aiSpeed = this.speed * 0.4; // Very slow
                        reactionDelay = 15; // Slow reaction
                        accuracy = 0.6; // 60% accuracy
                        break;
                    case 'medium':
                        aiSpeed = this.speed * 0.65; // Moderate speed
                        reactionDelay = 8; // Medium reaction
                        accuracy = 0.8; // 80% accuracy
                        break;
                    case 'hard':
                        aiSpeed = this.speed * 0.85; // Fast
                        reactionDelay = 3; // Quick reaction
                        accuracy = 0.95; // 95% accuracy
                        break;
                }
                
                // Add prediction for medium/hard difficulty
                if (gameDifficulty !== 'easy' && ball.vx > 0 && ball.vx !== 0) {
                    const timeToReach = (this.x - ball.x) / ball.vx;
                    if (timeToReach > 0 && timeToReach < 5) { // Reasonable time limit
                        let predictedY = ball.y + (ball.vy * timeToReach * accuracy) + ball.size / 2;
                        
                        // Handle wall bounces in prediction
                        if (predictedY < 0 || predictedY > canvas.height) {
                            predictedY = Math.max(0, Math.min(canvas.height, predictedY));
                        }
                        
                        targetY = predictedY;
                    }
                }
                
                // Add inaccuracy for easier difficulties
                if (Math.random() > accuracy) {
                    const errorRange = gameDifficulty === 'easy' ? 60 : 30;
                    targetY += (Math.random() - 0.5) * errorRange;
                }
                
                const diff = targetY - paddleCenter;
                
                // Add reaction delay
                if (Math.abs(diff) > reactionDelay) {
                    const moveDistance = Math.min(Math.abs(diff), aiSpeed);
                    if (diff > 0) this.y += moveDistance;
                    else this.y -= moveDistance;
                }
            }
            
            draw() {
                ctx.fillStyle = '#FFE81F';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Add glow effect
                ctx.shadowColor = '#FFE81F';
                ctx.shadowBlur = 10;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.shadowBlur = 0;
            }
        }
        
        class Ball {
            constructor() {
                this.size = GAME_CONFIG.BALL_SIZE;
                this.setSpeedByDifficulty();
                this.scored = false; // Prevent multiple scoring
                this.reset();
            }
            
            setSpeedByDifficulty() {
                switch(gameDifficulty) {
                    case 'easy':
                        this.baseSpeed = GAME_CONFIG.BALL_BASE_SPEED;
                        this.speedIncrease = 0.03;
                        break;
                    case 'medium':
                        this.baseSpeed = 4;
                        this.speedIncrease = 0.05;
                        break;
                    case 'hard':
                        this.baseSpeed = 5.5;
                        this.speedIncrease = 0.07;
                        break;
                }
                this.speed = this.baseSpeed;
            }
            
            reset(retryCount = 0) {
                // Ensure canvas dimensions are available with retry limit
                if (!canvas.width || !canvas.height) {
                    if (retryCount < GAME_CONFIG.MAX_BALL_RESET_RETRIES) { // Max 5 seconds of retries
                        setTimeout(() => this.reset(retryCount + 1), 100);
                        return;
                    } else {
                        // Fallback to default dimensions if canvas still not ready
                        console.warn('Canvas dimensions not available, using fallback');
                        this.x = 400; // Fallback canvas center
                        this.y = 300;
                        this.scored = false;
                        const angle = (Math.random() - 0.5) * Math.PI / 4;
                        const direction = Math.random() < 0.5 ? 1 : -1;
                        this.vx = Math.cos(angle) * this.speed * direction;
                        this.vy = Math.sin(angle) * this.speed;
                        return;
                    }
                }
                
                this.x = canvas.width / 2 - this.size / 2;
                this.y = canvas.height / 2 - this.size / 2;
                this.scored = false; // Reset scoring flag
                
                // Random direction
                const angle = (Math.random() - 0.5) * Math.PI / 4; // -45 to 45 degrees
                const direction = Math.random() < 0.5 ? 1 : -1;
                
                this.vx = Math.cos(angle) * this.speed * direction;
                this.vy = Math.sin(angle) * this.speed;
            }
            
            update() {
                // Don't update if ball is paused (off screen after scoring)
                if (this.vx === 0 && this.vy === 0 && this.x < 0) return;
                
                this.x += this.vx;
                this.y += this.vy;
                
                // Ball collision with top/bottom walls
                if (this.y <= 0) {
                    this.y = 0;
                    this.vy = Math.abs(this.vy); // Ensure ball moves down
                    playBeep(300, 0.1);
                } else if (this.y + this.size >= canvas.height) {
                    this.y = canvas.height - this.size;
                    this.vy = -Math.abs(this.vy); // Ensure ball moves up
                    playBeep(300, 0.1);
                }
                
                // Ball collision with paddles
                if (this.checkPaddleCollision(paddle1) || this.checkPaddleCollision(paddle2)) {
                    playBeep(500, 0.1);
                    
                    // Increase speed slightly
                    this.speed += this.speedIncrease;
                    const speedMultiplier = this.speed / this.baseSpeed;
                    this.vx = this.vx > 0 ? this.speed : -this.speed;
                    this.vy *= speedMultiplier;
                }
                
                // Scoring - prevent multiple scores
                if (!this.scored) {
                    if (this.x < -this.size) {
                        paddle2.score++; // AI scores
                        this.scored = true;
                        
                        // AI heckles when player loses a point
                        aiHeckle();
                        
                        this.scoreAndReset();
                    } else if (this.x > canvas.width) {
                        paddle1.score++; // Player scores
                        this.scored = true;
                        this.scoreAndReset();
                    }
                }
            }
            
            checkPaddleCollision(paddle) {
                // Check if ball is already moving away from paddle to prevent double bounces
                if (paddle.isPlayer1 && this.vx > 0) return false;
                if (!paddle.isPlayer1 && this.vx < 0) return false;
                
                if (this.x < paddle.x + paddle.width &&
                    this.x + this.size > paddle.x &&
                    this.y < paddle.y + paddle.height &&
                    this.y + this.size > paddle.y) {
                    
                    // Calculate hit position for realistic physics
                    const hitPos = ((this.y + this.size/2) - (paddle.y + paddle.height/2)) / (paddle.height/2);
                    const angle = Math.max(-1, Math.min(1, hitPos)) * Math.PI/4; // Clamp and max 45 degree angle
                    
                    // Reverse x direction and apply angle
                    this.vx = -this.vx;
                    this.vy = Math.sin(angle) * Math.abs(this.vx);
                    
                    // Move ball away from paddle to prevent multiple collisions
                    if (paddle.isPlayer1) {
                        this.x = paddle.x + paddle.width + 2; // Increased clearance
                    } else {
                        this.x = paddle.x - this.size - 2; // Increased clearance
                    }
                    
                    return true;
                }
                return false;
            }
            
            scoreAndReset() {
                playBeep(200, 0.3);
                updateScore();
                
                if (paddle1.score >= GAME_CONFIG.WINNING_SCORE || paddle2.score >= GAME_CONFIG.WINNING_SCORE) {
                    endGame();
                    return;
                }
                
                // Brief pause before reset - but keep game loop running
                this.x = -100; // Move ball off screen temporarily
                this.vx = 0;
                this.vy = 0;
                
                setTimeout(() => {
                    this.speed = this.baseSpeed; // Reset ball speed
                    this.reset(); // This will put ball back in center and give it velocity
                }, 1000);
            }
            
            draw() {
                // Ensure ball has valid position
                if (this.x === undefined || this.y === undefined) return;
                
                ctx.fillStyle = '#FFE81F';
                
                // Add glow effect first
                ctx.shadowColor = '#FFE81F';
                ctx.shadowBlur = 15;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                
                // Draw solid ball on top
                ctx.shadowBlur = 0;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                
                // Add a bright center
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(this.x + 2, this.y + 2, this.size - 4, this.size - 4);
            }
        }
        
        // Countdown state
        let countdown = {
            active: false,
            number: 3,
            startTime: 0
        };
        
        // Menu functions
        function showDifficultyMenu() {
            // Initialize audio on user interaction
            ensureAudioContext();
            
            document.getElementById('gameMenu').classList.add('hidden');
            document.getElementById('difficultyMenu').classList.remove('hidden');
        }
        
        function returnToMainMenu() {
            hideAllMenus();
            document.getElementById('gameMenu').classList.remove('hidden');
            
            // Show speech test button again when returning to menu
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile || speechDebugMode) {
                document.getElementById('speechTestBtn').style.display = 'block';
                document.getElementById('speechDebug').style.display = 'block';
            }
        }
        
        function showPlayerSetup(mode, difficulty = 'medium') {
            // Initialize audio on user interaction
            ensureAudioContext();
            
            hideAllMenus();
            document.getElementById('playerSetup').classList.remove('hidden');
            
            // Store the game mode and difficulty for later
            window.pendingGameMode = mode;
            window.pendingDifficulty = difficulty;
            
            // Set default names
            document.getElementById('player1NameInput').value = player1Name;
            
            if (mode === 'ai') {
                // Hide player 2 setup for AI mode
                document.getElementById('player2Setup').style.display = 'none';
            } else {
                // Show player 2 setup for two player mode
                document.getElementById('player2Setup').style.display = 'block';
                document.getElementById('player2NameInput').value = player2Name === 'Darth Vader' ? 'Player 2' : player2Name;
            }
        }
        
        // Input validation function
        function validatePlayerName(name) {
            // Remove any HTML tags for security
            const cleaned = name.replace(/<[^>]*>/g, '');
            
            // Limit to alphanumeric, spaces, and common punctuation
            const sanitized = cleaned.replace(/[^a-zA-Z0-9\s\-_\.]/g, '');
            
            // Trim and limit length
            const trimmed = sanitized.trim().substring(0, GAME_CONFIG.MAX_PLAYER_NAME_LENGTH);
            
            return trimmed || 'Player';
        }
        
        function confirmPlayerSetup() {
            // Get names from inputs with validation
            const p1Input = document.getElementById('player1NameInput').value.trim();
            const p1Name = validatePlayerName(p1Input) || 'Player 1';
            let p2Name;
            
            if (window.pendingGameMode === 'ai') {
                p2Name = 'Darth Vader';
            } else {
                const p2Input = document.getElementById('player2NameInput').value.trim();
                p2Name = validatePlayerName(p2Input) || 'Player 2';
            }
            
            // Update player names
            player1Name = p1Name;
            player2Name = p2Name;
            
            // Start the game
            startGame(window.pendingGameMode, window.pendingDifficulty);
        }
        
        function backFromPlayerSetup() {
            if (window.pendingGameMode === 'ai') {
                hideAllMenus();
                document.getElementById('difficultyMenu').classList.remove('hidden');
            } else {
                hideAllMenus();
                document.getElementById('gameMenu').classList.remove('hidden');
            }
        }
        
        function hideAllMenus() {
            document.getElementById('gameMenu').classList.add('hidden');
            document.getElementById('difficultyMenu').classList.add('hidden');
            document.getElementById('playerSetup').classList.add('hidden');
            document.getElementById('roundEndMenu').classList.add('hidden');
            document.getElementById('nameChangeMenu').classList.add('hidden');
        }
        
        function showRoundEndMenu() {
            hideAllMenus();
            document.getElementById('roundEndMenu').classList.remove('hidden');
            
            // Update score display
            const scoreText = `${player1Name}: ${paddle1.score} | ${player2Name}: ${paddle2.score}`;
            document.getElementById('roundScore').textContent = scoreText;
        }
        
        function continueGame() {
            hideAllMenus();
            // Reset scores and continue
            paddle1.score = 0;
            paddle2.score = 0;
            updateScore();
            startCountdown();
        }
        
        function showNameChange() {
            hideAllMenus();
            document.getElementById('nameChangeMenu').classList.remove('hidden');
            
            // Pre-fill current names
            document.getElementById('newPlayer1Name').value = player1Name;
            
            if (gameMode === 'ai') {
                document.getElementById('nameChangePlayer2').style.display = 'none';
            } else {
                document.getElementById('nameChangePlayer2').style.display = 'block';
                document.getElementById('newPlayer2Name').value = player2Name;
            }
        }
        
        function applyNameChanges() {
            player1Name = document.getElementById('newPlayer1Name').value.trim() || player1Name;
            
            if (gameMode !== 'ai') {
                player2Name = document.getElementById('newPlayer2Name').value.trim() || player2Name;
            }
            
            updatePlayerNames();
            backToRoundEnd();
        }
        
        function backToRoundEnd() {
            hideAllMenus();
            document.getElementById('roundEndMenu').classList.remove('hidden');
        }
        
        // Game functions
        function startGame(mode, difficulty = 'medium') {
            // Hide speech test button when game starts
            document.getElementById('speechTestBtn').style.display = 'none';
            document.getElementById('speechDebug').style.display = 'none';
            
            // Initialize audio with user interaction
            initAudio().then(() => {
                ensureAudioContext();
            });
            
            // Initialize speech synthesis for mobile
            initSpeechSynthesis();
            
            gameMode = mode;
            gameDifficulty = difficulty;
            
            // Hide all menus
            hideAllMenus();
            
            // Ensure canvas is properly sized before creating objects
            resizeCanvas();
            
            // Initialize game objects with reset scores
            paddle1 = new Paddle(30, canvas.height / 2 - 40, true);
            paddle2 = new Paddle(canvas.width - 45, canvas.height / 2 - 40, false);
            
            // Reset scores completely
            paddle1.score = 0;
            paddle2.score = 0;
            updateScore();
            updatePlayerNames();
            
            // Start countdown before game begins
            startCountdown();
        }
        
        function startCountdown() {
            countdown.active = true;
            countdown.number = 3;
            countdown.startTime = Date.now();
            
            gameRunning = false; // Don't start game loop yet
            animateCountdown();
        }
        
        function animateCountdown() {
            if (!countdown.active) return;
            
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 4, 40, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw game elements in background
            drawCenterLine();
            if (paddle1) paddle1.draw();
            if (paddle2) paddle2.draw();
            
            // Draw countdown overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate countdown timing
            const elapsed = Date.now() - countdown.startTime;
            const secondsPassed = Math.floor(elapsed / 1000);
            
            if (secondsPassed < 3) {
                const currentNumber = 3 - secondsPassed;
                const progress = (elapsed % 1000) / 1000;
                
                // Draw countdown number with scaling effect
                ctx.fillStyle = '#FFE81F';
                ctx.shadowColor = '#FFE81F';
                ctx.shadowBlur = 30;
                ctx.textAlign = 'center';
                
                const scale = 1 + (1 - progress) * 0.5; // Scale from 1.5 to 1
                const fontSize = 120 * scale;
                ctx.font = `bold ${fontSize}px Orbitron`;
                
                ctx.fillText(currentNumber.toString(), canvas.width / 2, canvas.height / 2);
                
                // Play beep sound
                if (progress < 0.1 && currentNumber !== countdown.number) {
                    playBeep(600, 0.2);
                    countdown.number = currentNumber;
                }
                
                scheduleNextFrame(animateCountdown);
            } else {
                // Countdown finished - start game
                countdown.active = false;
                
                // Ensure game state is properly initialized before creating objects
                if (!paddle1 || !paddle2) {
                    console.error('Paddles not initialized, cannot start game');
                    returnToMenu();
                    return;
                }
                
                // Create ball with proper initialization check
                try {
                    ball = new Ball();
                    if (!ball || ball.x === undefined || ball.y === undefined) {
                        throw new Error('Ball initialization failed');
                    }
                } catch (error) {
                    console.error('Failed to create ball:', error);
                    returnToMenu();
                    return;
                }
                
                // Only set gameRunning to true after all objects are properly initialized
                gameRunning = true;
                
                // Play start sound
                playBeep(800, 0.3);
                
                gameLoop();
            }
        }
        
        function endGame() {
            gameRunning = false;
            const winner = paddle1.score >= GAME_CONFIG.WINNING_SCORE ? player1Name : player2Name;
            
            // Save scores
            saveScores();
            
            // Start Star Wars win animation
            showWinAnimation(winner);
        }
        
        function returnToMenu() {
            gameRunning = false;
            gamePaused = false;
            
            // Clean up all intervals to prevent memory leaks
            clearAllIntervals();
            
            // Show main menu, hide all others
            hideAllMenus();
            document.getElementById('gameMenu').classList.remove('hidden');
            
            // Reset all game objects and scores
            if (paddle1) paddle1.score = 0;
            if (paddle2) paddle2.score = 0;
            paddle1 = null;
            paddle2 = null;
            ball = null;
            
            // Reset game mode and difficulty
            gameMode = null;
            gameDifficulty = 'medium';
            
            // Reset player names to defaults
            player1Name = 'Player 1';
            player2Name = 'Player 2';
            updatePlayerNames();
            
            // Reset insult tracking
            usedInsults = [];
            currentInsultIndex = 0;
            
            // Update score display
            player1ScoreEl.textContent = '0';
            player2ScoreEl.textContent = '0';
        }
        
        function togglePause() {
            if (!gameRunning) return;
            
            gamePaused = !gamePaused;
        }
        
        function updateScore() {
            player1ScoreEl.textContent = paddle1.score;
            player2ScoreEl.textContent = paddle2.score;
        }
        
        function updatePlayerNames() {
            document.getElementById('player1Name').textContent = player1Name;
            document.getElementById('player2Name').textContent = player2Name;
        }
        
        function saveScores() {
            const scores = {
                player1: paddle1.score,
                player2: paddle2.score,
                gameMode: gameMode,
                timestamp: Date.now()
            };
            
            try {
                // Check if localStorage is available
                if (typeof Storage === 'undefined') {
                    console.warn('localStorage not supported');
                    return;
                }
                
                const scoreData = JSON.stringify(scores);
                
                // Check data size (localStorage typically has 5-10MB limit)
                if (scoreData.length > GAME_CONFIG.LOCALSTORAGE_SIZE_LIMIT) { // 1MB safety limit
                    console.warn('Score data too large, skipping save');
                    return;
                }
                
                localStorage.setItem('starWarsPongScores', scoreData);
            } catch (error) {
                if (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                    console.warn('localStorage quota exceeded, clearing old data');
                    try {
                        // Clear old game data and try again
                        localStorage.removeItem('starWarsPongScores');
                        localStorage.setItem('starWarsPongScores', JSON.stringify(scores));
                    } catch (retryError) {
                        console.error('Failed to save scores even after cleanup:', retryError);
                    }
                } else {
                    console.error('Failed to save scores:', error);
                }
            }
        }
        
        
        // Game loop
        function gameLoop() {
            if (!gameRunning || countdown.active) return;
            
            // Update FPS counter
            updateFpsCounter();
            
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 4, 40, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!gamePaused) {
                // Update game objects
                if (paddle1) paddle1.update();
                if (paddle2) paddle2.update();
                if (ball && ball.x > -50) ball.update(); // Only update ball if it's on screen
            }
            
            // Draw everything
            drawCenterLine();
            if (paddle1) paddle1.draw();
            if (paddle2) paddle2.draw();
            if (ball && ball.x > -50) ball.draw(); // Only draw ball if it's on screen
            
            // Draw AI heckling text
            drawHeckleText();
            
            // Show score pause message when ball is off screen
            if (ball && ball.x <= -50 && ball.vx === 0) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#FFE81F';
                ctx.font = '36px Orbitron';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#FFE81F';
                ctx.shadowBlur = 15;
                ctx.fillText('POINT SCORED!', canvas.width / 2, canvas.height / 2 - 20);
                ctx.font = '20px Orbitron';
                ctx.fillText('Next round starting...', canvas.width / 2, canvas.height / 2 + 20);
                ctx.shadowBlur = 0;
            }
            
            if (gamePaused) {
                drawPauseScreen();
            }
            
            // Schedule next frame with unlimited FPS capability
            scheduleNextFrame(gameLoop);
        }
        
        function drawCenterLine() {
            ctx.strokeStyle = '#FFE81F';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawPauseScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FFE81F';
            ctx.font = '48px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            ctx.font = '24px Orbitron';
            ctx.fillText('Press SPACE to continue', canvas.width / 2, canvas.height / 2 + 50);
        }
        
        // Star Wars rolling credits win animation
        let winAnimation = {
            active: false,
            scrollY: 0,
            winner: '',
            startTime: 0
        };
        
        function showWinAnimation(winner) {
            winAnimation.active = true;
            winAnimation.winner = winner;
            winAnimation.scrollY = canvas.height;
            winAnimation.startTime = Date.now();
            
            // Play appropriate music and Vader reactions
            if (winner === player1Name && gameMode === 'ai') {
                // Player beats AI - Vader screams NOOO and play victory music
                setTimeout(() => {
                    speakAsVader("Nooooooooo", true); // Use isScream = true for sustained sound
                }, 500);
                playVictoryMusic();
            } else if (winner === 'Darth Vader') {
                // AI wins - play Imperial March
                playDefeatMusic();
            } else {
                // Two player mode - just play victory music
                playVictoryMusic();
            }
            
            animateWinScreen();
        }
        
        function animateWinScreen() {
            if (!winAnimation.active) return;
            
            // Clear screen with starfield effect
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars
            ctx.fillStyle = '#FFF';
            for (let i = 0; i < 50; i++) {
                const x = (i * 67) % canvas.width;
                const y = (i * 91 + winAnimation.scrollY * 0.1) % canvas.height;
                ctx.fillRect(x, y, 1, 1);
            }
            
            // Create perspective text effect
            ctx.save();
            
            // Set up perspective transformation
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Transform for perspective
            ctx.translate(centerX, centerY);
            ctx.scale(1, 0.5); // Flatten for perspective
            ctx.rotate(-0.3); // Angle like Star Wars crawl
            
            // Calculate text position
            const textY = winAnimation.scrollY - centerY;
            
            // Draw the win text
            ctx.fillStyle = '#FFE81F';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#FFE81F';
            ctx.shadowBlur = 20;
            
            // Title
            ctx.font = 'bold 60px Orbitron';
            ctx.fillText('VICTORY!', 0, textY - 200);
            
            // Winner announcement
            ctx.font = 'bold 40px Orbitron';
            ctx.fillText(`${winAnimation.winner} WINS`, 0, textY - 100);
            
            // Episode text
            ctx.font = '24px Orbitron';
            ctx.fillText('Episode VII', 0, textY - 300);
            
            // Story text
            ctx.font = '18px Orbitron';
            const storyLines = [
                'In a galaxy far, far away,',
                'a epic battle of paddles',
                'has reached its conclusion.',
                '',
                `The ${winAnimation.winner} has emerged`,
                'victorious in the ultimate',
                'game of PONG.',
                '',
                'The Force was strong with',
                'this one. Through skill,',
                'determination, and perhaps',
                'a little luck, victory was',
                'achieved.',
                '',
                'May the Force be with you',
                'in future battles...',
                '',
                'Press ESC to return to',
                'the main menu'
            ];
            
            storyLines.forEach((line, index) => {
                ctx.fillText(line, 0, textY + (index * 30));
            });
            
            ctx.restore();
            
            // Update scroll position
            winAnimation.scrollY -= 2;
            
            // Continue animation or end it
            if (winAnimation.scrollY > -1000) {
                scheduleNextFrame(animateWinScreen);
            } else {
                setTimeout(() => {
                    winAnimation.active = false;
                    returnToMenu();
                }, 2000);
            }
        }
        
        // Touch event handlers
        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            
            // Account for device pixel ratio and zoom levels
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // Calculate position relative to canvas bounds
            const relativeX = touch.clientX - rect.left;
            const relativeY = touch.clientY - rect.top;
            
            return {
                x: relativeX * scaleX,
                y: relativeY * scaleY
            };
        }
        
        function isPaddleTouch(touch, paddle) {
            const pos = getTouchPos(touch);
            return pos.x >= paddle.x - 20 && pos.x <= paddle.x + paddle.width + 20 &&
                   pos.y >= paddle.y - 20 && pos.y <= paddle.y + paddle.height + 20;
        }
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            
            // Ensure audio context is resumed on touch
            ensureAudioContext();
            
            // Don't handle touch if in menu or game not running
            if (!gameRunning || gamePaused || !document.getElementById('gameMenu').classList.contains('hidden')) return;
            
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                
                // Check if touching paddle1
                if (paddle1 && isPaddleTouch(touch, paddle1) && !touchControls.paddle1Touch) {
                    touchControls.paddle1Touch = touch.identifier;
                    touchControls.startY = getTouchPos(touch).y;
                }
                
                // Check if touching paddle2 (only in two-player mode)
                if (gameMode === 'twoPlayer' && paddle2 && isPaddleTouch(touch, paddle2) && !touchControls.paddle2Touch) {
                    touchControls.paddle2Touch = touch.identifier;
                    touchControls.startY = getTouchPos(touch).y;
                }
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            // Don't handle touch if in menu or game not running
            if (!gameRunning || gamePaused || !document.getElementById('gameMenu').classList.contains('hidden')) return;
            
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                const pos = getTouchPos(touch);
                
                // Handle paddle1 touch
                if (touchControls.paddle1Touch === touch.identifier && paddle1) {
                    const deltaY = pos.y - touchControls.startY;
                    if (Math.abs(deltaY) > touchControls.dragThreshold) {
                        paddle1.y = pos.y - paddle1.height / 2;
                        touchControls.startY = pos.y;
                    }
                }
                
                // Handle paddle2 touch (only in two-player mode)
                if (gameMode === 'twoPlayer' && touchControls.paddle2Touch === touch.identifier && paddle2) {
                    const deltaY = pos.y - touchControls.startY;
                    if (Math.abs(deltaY) > touchControls.dragThreshold) {
                        paddle2.y = pos.y - paddle2.height / 2;
                        touchControls.startY = pos.y;
                    }
                }
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                
                // Release paddle1 touch
                if (touchControls.paddle1Touch === touch.identifier) {
                    touchControls.paddle1Touch = null;
                }
                
                // Release paddle2 touch
                if (touchControls.paddle2Touch === touch.identifier) {
                    touchControls.paddle2Touch = null;
                }
            }
        });
        
        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                
                // Release paddle1 touch
                if (touchControls.paddle1Touch === touch.identifier) {
                    touchControls.paddle1Touch = null;
                }
                
                // Release paddle2 touch
                if (touchControls.paddle2Touch === touch.identifier) {
                    touchControls.paddle2Touch = null;
                }
            }
        });
        
        // Event listeners
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === ' ') {
                e.preventDefault();
                if (!winAnimation.active && !countdown.active) {
                    togglePause();
                }
            } else if (e.key === 'Escape') {
                if (winAnimation.active) {
                    winAnimation.active = false;
                }
                if (countdown.active) {
                    countdown.active = false;
                }
                returnToMenu();
            } else if (e.key === 'f' || e.key === 'F') {
                e.preventDefault();
                toggleFpsDisplay();
            } else if (e.key === 'u' || e.key === 'U') {
                e.preventDefault();
                cycleFpsMode();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        window.addEventListener('resize', () => {
            resizeCanvas();
            if (paddle1 && paddle2) {
                // Reposition paddles on resize
                paddle2.x = canvas.width - 45;
            }
        });
        
        // Initialize
        resizeCanvas();
        
        // Mobile audio setup
        function setupMobileAudio() {
            // Detect mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                // Add mobile-specific touch handlers for better audio initialization
                document.addEventListener('touchstart', function() {
                    ensureAudioContext();
                }, { once: true });
                
                // Show FPS display by default on mobile for performance monitoring
                setTimeout(() => {
                    if (!fpsCounter.displayEnabled) {
                        toggleFpsDisplay();
                    }
                }, 1000);
            }
        }
        
        // Setup mobile audio when page loads
        setupMobileAudio();
        
        // Add click handler to any button for audio initialization
        document.addEventListener('click', ensureAudioContext);
        
        // Initialize speech synthesis immediately
        initSpeechSynthesis();
        
        // Add additional mobile-specific speech initialization
        document.addEventListener('touchstart', function initMobileSpeech() {
            if (!speechInitialized) {
                initSpeechSynthesis();
                audioInitialized = true;
            }
        }, { once: true });
        
        // Aggressive mobile speech initialization
        function setupMobileSpeechDebugging() {
            console.log('📱 Setting up mobile speech debugging');
            
            // Multiple event listeners for speech initialization
            const events = ['touchstart', 'click', 'touchend', 'pointerdown'];
            events.forEach(eventType => {
                document.addEventListener(eventType, function initMobileSpeech() {
                    console.log(`🔄 Speech init triggered by ${eventType}`);
                    audioInitialized = true;
                    if (!speechInitialized) {
                        initSpeechSynthesis();
                    }
                    showSpeechDebug();
                    
                    // Test speech synthesis immediately
                    setTimeout(() => {
                        testSpeechSynthesis();
                    }, 500);
                }, { once: true });
            });
            
            // Force speech synthesis to load voices on mobile
            if (speechSynthesis) {
                speechSynthesis.getVoices();
                
                // Repeated voice loading attempts
                let voiceLoadAttempts = 0;
                const voiceLoader = createManagedInterval(() => {
                    voiceLoadAttempts++;
                    speechSynthesis.getVoices();
                    
                    if (speechSynthesis.getVoices().length > 0 || voiceLoadAttempts > 20) {
                        clearManagedInterval(voiceLoader);
                        if (speechSynthesis.getVoices().length > 0) {
                            console.log('✅ Voices loaded after', voiceLoadAttempts, 'attempts');
                            initSpeechSynthesis();
                        }
                    }
                }, 250);
            }
        }
        
        // Test speech synthesis function
        function testSpeechSynthesis() {
            console.log('🧪 Testing speech synthesis...');
            
            if (!speechSynthesis) {
                console.error('❌ speechSynthesis not available');
                return;
            }
            
            try {
                const testUtterance = new SpeechSynthesisUtterance('Test');
                testUtterance.volume = 0.1; // Quiet test
                testUtterance.rate = 2.0; // Fast test
                
                testUtterance.onstart = () => {
                    console.log('✅ Speech synthesis test PASSED');
                    document.getElementById('speechStatus').textContent = 'WORKING';
                };
                
                testUtterance.onerror = (e) => {
                    console.error('❌ Speech synthesis test FAILED:', e.error);
                    document.getElementById('speechStatus').textContent = 'FAILED';
                    lastSpeechError = `Test failed: ${e.error}`;
                    updateSpeechDebug();
                };
                
                speechSynthesis.speak(testUtterance);
                
            } catch (error) {
                console.error('❌ Speech test error:', error);
                lastSpeechError = `Test error: ${error.message}`;
                updateSpeechDebug();
            }
        }
        
        // Setup mobile speech debugging
        setupMobileSpeechDebugging();
        
        // Mobile FPS button fix
        function setupMobileFpsButton() {
            const fpsButton = document.getElementById('fpsButton');
            if (fpsButton) {
                // Add touch event listeners for better mobile support
                fpsButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.style.transform = 'scale(1.05)';
                    this.style.background = 'rgba(255, 232, 31, 0.3)';
                }, { passive: false });
                
                fpsButton.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.style.transform = 'scale(1)';
                    this.style.background = 'rgba(0, 0, 0, 0.8)';
                    toggleFpsDisplay();
                }, { passive: false });
                
                fpsButton.addEventListener('touchcancel', function(e) {
                    e.preventDefault();
                    this.style.transform = 'scale(1)';
                    this.style.background = 'rgba(0, 0, 0, 0.8)';
                }, { passive: false });
            }
        }
        
        // Setup mobile FPS button when page loads
        setupMobileFpsButton();
        
        // Prevent default arrow key scrolling
        window.addEventListener('keydown', (e) => {
            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });
    </script>
</body>
</html>